---
title: "To Cull or Not to Cull? Using Population Projection Modeling to Reveal Risk-Sensitive Herd Culling Strategies in Neolithic Dalmatia"
subtitle: "Supplemental Information 3"
author: "Nicholas Triozzi"
date: "2025-02-25"
output: github_document
bibliography: Appendix_bib.bib
link-citations: TRUE
---

# Livestock Population Dynamics and Optimziation of Culling Rates

## Introduction

This document outlines the procedures used to simulate goat and sheep herd dynamics under the constraints of various culling strategies. The content of this document and associated scripts are supporting materials for "To Cull or Not to Cull? Using Population Projection Modeling to Reveal Risk-Sensitive Herd Culling Strategies in Neolithic Dalmatia".

```{r, setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# install.packages("devtools")
devtools::install_github("penguinnick/HerdDynamics")
library(HerdDynamics)
library(dplyr)
library(tidyr)
library(purrr)
library(boot)
library(flextable)
library(stringr)
library(rcartocolor)
library(officer)
library(ggplot2)
library(car)
# using( "tidyverse", "mmage", "rcartocolor", "flextable", "officer", "boot", "zoo", "FSA", "car")
```

```{r flextable-defaults, include=FALSE}
set_flextable_defaults(
  font.family = "Helvetica",
  font.size = 10,
  padding = 2,
  line_spacing = 1.2,
  table.layout = "autofit"
)
```

## Overview
The population projection model presented here uses the [HerdDynamics](https://github.com/penguinnick/HerdDynamics) package for R, which features wrapper functions for the [mmage package](https://gitlab.cirad.fr/selmet/livtools/mmage) [@Lesnoff2024] and customized scripts for comparing different herd culling strategies [@Triozzi2024]. In the `HerdDynamics` package, some procedures described in the [mmage reference manual](https://gitlab.cirad.fr/selmet/livtools/mmage/-/blob/master/doc/mmage_v1.7.pdf?ref_type=heads) have been consolidated into wrapper functions such as "build_tcla", and "build.param".

The `HerdDynamics` package is designed to be used with the `mmage` package, which is a powerful tool for analyzing age-structured populations. The `HerdDynamics` package provides additional functionality for simulating herd dynamics and optimizing culling strategies.

# Part I - Setup - Population Projection Matrix

Here, a Lefkovitch population projection model [@Lefkovitch1965] is used to project sheep and goat herd population dynamics. The probability of survival and fecundity are influenced by the competing risks of intrinsic mortality and offtake (i.e., slaugther). The transition matrix is created using published data on fecundity, intrinsic mortality , and offtake rates which are derived from theoretical culling profiles in archaeological literature (See Supplementary Information 2). 

### Age Classes

The first step is to establish age classes for the simulation. 
The age classes according to Payne [-@Payne1973] are included in  `HerdDynamics` as `Payne_ages`. Note the last value in `lclass` is set to `Inf`. The model presented here is an "untruncated" model since the final age class includes animals 8 years old and up, with no terminal age specified for old animals.

```{r, define-ageclass}
HerdDynamics::Payne_ages
```
### Transition Class Table (tcla)
Once the age classes are set, the wrapper function `build_tcla()` from `HerdDynamics` uses the `mmage::fclass` function to create the data.frame `tcla`. Parameter `nbphase` sets the timestep interval, which should be either annually (12) or monthly (1). The `tcla` data.frame consists of the length of each group (i.e., 2 months, 4 months, 6 months, 12 months, etc.) and the minimum and maximum ages of the group for males and females. This procedure is streamlined by the customized `build_tcla` function which is designed to adjust the values provided as input (lclass) according to `nbphase`, and recognize whether `lclass` is formatted for a "truncated" or "untruncated" model. We use the `lclass` variable in the `Payne_ages` table provided by `HerdDynamics`, which has already been set up to track age in months. So we can set `nbphase` to 1.

```{r, tcla}
#-- Build tcla table using HerdDynamics::build_tcla() 
nbphase = 1
tcla = build_tcla(
  female.ages = Payne_ages$lclass,
  male.ages = Payne_ages$lclass,
  nbphase = nbphase
)
tcla
```


### Herd Culling Strategies

Calling `HerdDynamics::offtake_models` gives a list of survivorship probabilities standardized across nine age classes by Marom and Bar-Oz [-@Marom2009] for Redding's [-@Redding1981] **Energy** and **Security**,  Payne's [-@Payne1973] **Meat**, **Milk**, and **Wool** strategies, and Vigne and Helmer's [-@Vigne2007] Meat and Milk types A and B (**MeatA**, **MeatB**, **MilkA**, **MilkB**) and **Fleece** strategies.

```{r, theoretical-offtake-models, include=TRUE, eval=TRUE, fig.dim=c(6 , 4), fig.cap="Figure S3.1. Survivorship curves for threoretical culling strategies."}
HerdDynamics::culling_multiplot(HerdDynamics::offtake_models)
```

```{r, save-fig1, include=FALSE}
ggsave(
  plot = HerdDynamics::culling_multiplot(HerdDynamics::offtake_models),
  "Figures/Fig1_TheoreticalCullingStrategies.jpg",
  dpi = 300,
  width = 6,
  height = 4
)

```

```{r, theoretical-survivorship-table, echo=FALSE, include=FALSE} 
#, include=FALSE, eval=TRUE, results="hide"}
T2 = cbind.data.frame(c("", Payne_ages$ageClasses) ,
                      do.call(cbind.data.frame, args = c(offtake_models)))
colnames(T2)[1] = "Age Class" # = ageClasses # c(0, ages)

T2ft = flextable(T2[-1, ]) %>%
  set_header_labels(
    MeatA = "Meat A",
    MeatB = "Meat B",
    MilkA = "Milk A",
    MilkB = "Milk B"
  ) %>%
  # footnote( i = 1, j = 1, value = as_paragraph( c("Marom and Bar-Oz (2009)" )),
  #               ref_symbols = c("a" ),
  #               part = "header",inline = T) %>%
  footnote(
    i = 1,
    j = 2:3,
    value = as_paragraph(c("Redding (1981)")),
    ref_symbols = c("a"),
    part = "header",
    inline = T
  ) %>%
  footnote(
    i = 1,
    j = c(4:6),
    value = as_paragraph(c("Payne (1973)")),
    ref_symbols = c("b"),
    part = "header",
    inline = T
  ) %>%
  footnote(
    i = 1,
    j = 7:11,
    value = as_paragraph(c("Vigne and Helmer (2007)")),
    ref_symbols = c("c"),
    part = "header",
    inline = T
  ) %>%
  autofit() %>%
  set_table_properties(
    layout = "autofit",
    align = "center"
    # opts_word = list("split" = FALSE, "keep_with_next" = TRUE)
  ) %>%
  paginate(
    group = "Age Class",
    # keep Sample.ID group across pages
    group_def = "rle"
  ) %>%
  theme_vanilla() %>%
  set_caption(
    "Table 2. Percentage of herd predicted to survive under ten theoretical culling strategies associated with different production strategies, as presented by Marom and Bar-Oz (2009a). Survival probabilities derived from aRedding (1981), bPayne (1973), and cVigne and Helmer (2007) correspond to Payne's age class system."
  )


#-- properties for word doc output
sect_properties <- prop_section(
  page_size = page_size(
    # orient = "landscape",
    orient = "portrait",
    width = 8.5,
    height = 11
  ),
  type = "continuous",
  # page_margins = page_mar(top = 1.25)
  # page_margins = page_mar(left = 1)
)
getwd()

#-- create output word doc
save_as_docx(T2ft, path = "tables/Table2_survival_rates.docx", pr_section = sect_properties)
# T2ft  
# rm(T2, T2ft)
```

```{r, T2, echo=FALSE}
T2ft %>%
  set_caption(
    "Table 2. Percentage of herd predicted to survive under ten theoretical culling strategies associated with different production strategies, as presented by Marom and Bar-Oz (2009a). Survival probabilities derived from aRedding (1981), bPayne (1973), and cVigne and Helmer (2007) correspond to Payne's age class system."
  )
```

### Age-at-death data from four Neolithic sites

Age-at-death data for sheep and goat mandibles collected from **Benkovac-Barice**, **Graduša-Lokve at Islam Grčki**, **Smilčić**, and **Zemunik Donji** are used to create survival probabilities for each age class [@Triozzi2024]. The data is accessible via Zenodo [@Triozzi2025]  [ https://doi.org/https://doi.org/10.5281/zenodo.17697101] 

The data is included in the `age_at_death_data.csv` file and combines all goats and sheep as ovicaprids. The absolute frequencies are calculated using `HerdDynamics::correct_counts()` to account for mandibles that were assigned multiple age classes. Survivorship probabilities are calculated following Price et al. [-@Price2016], using the function `HerdDynamics::survivorship()`. In a final step the data is formatted as a list to conform with the `offtake.models` list created previously.

```{r, age-at-death data, include = FALSE}
#-- read in age-at-death data
wear.df = read.table(file = "./data/age_at_death_data.csv", sep = ",")

#-- create list for each site/period
wear.df.list = wear.df %>%
  group_by(Site, Period) %>%
  group_split(.keep = T)

#-- get names
l.names = wear.df %>%
  group_by(Site, Period) %>%
  group_keys() %>%
  reframe(name = paste(Site, Period))

#-- assign names to each list
names(wear.df.list) = l.names$name

cprof <- lapply(wear.df.list, function(w){
  t <- correct.counts(w$Payne.Group, probability.correction = FALSE)
  t <- cbind.data.frame(t, s = survivorship(t$n))
  HI = 1 - (sqrt (1 -  t$s[8]))
  G = 1 - (sqrt(1 - t$s[7]))
  t$s[7] = t$s[8] = G
  t$s[9] = HI
  list(t = t, culling.profile =  c(100, t$s * 100))
})
cprof <- lapply(cprof, function(x){
  x$culling.profile})

culling.profiles <- cprof
# rm(wear.df, wear.df.list, ages.list, l.names)
```

```{r, Figure2, include=FALSE}
#-- save Figure 2 with archaeological survivorship curves
#-- use HerdDynamics functions to calculate survivorship from age-at-death data
ages.list = lapply(wear.df.list, function(a) {
  # adjusts counts for each age group where multiple age groups are listed,
  # t = correct.counts(a$Payne.Group, probability.correction = FALSE);
  t = correct.counts(a$Payne.Group, probability.correction = TRUE)
  
  # calculates survivorship
  cbind.data.frame(t, s = survivorship(t$n))
})

#-- return to dataframe for plotting
ages.df.correct <- bind_rows(ages.list, .id = "Site_Period") %>%
  mutate(
    Freq.Dens = fd,
    Age = case_when(
      # add ages in months to age classes
      v == "A" ~ "0-2m",
      v == "B" ~ "2-6m",
      v == "C" ~ "6-12m",
      v == "D" ~ "12-24m",
      v == "EF" ~ "24-48m",
      v == "G" ~ "48-72m",
      v == "HI" ~ ">72m"
    )
  ) %>%
  mutate(Age = paste0(v, " (", Age, ")")) %>%
  group_by(Site_Period) %>%
  mutate(
    # calculate percent of cumulative frequency density
    fd.percent = Freq.Dens / sum(Freq.Dens)
  ) %>%
  mutate(
    # factor site-period field
    Site_Period = factor(
      Site_Period,
      levels = c(
        # "Crno Vrilo (Sierra) EN",
        "Smilčić EN" ,
        "Smilčić MN",
        "Benkovac-Barice MN",
        "Zemunik Donji MN",
        "Islam Grčki MN",
        "Islam Grčki LN"
      ) ,
      labels = c(
        # "Crno Vrilo (Impresso)",
        "Smilčić (Impresso)",
        "Smilčić (Danilo)",
        "Benkovac-Barice (Danilo)",
        "Zemunik Donji (Danilo)",
        "Islam Grčki (Danilo)",
        "Islam Grčki (Hvar)"
      )
    )
  )

#-- create strip labels for facets
strip.labeller = ages.df.correct %>%
  filter(!is.na(Site_Period)) %>%
  mutate(
    strat.lab = case_when(
      str_detect(Site_Period, "Benko") ~ paste0(Site_Period, " \n Milk A/B + Meat B"),
      Site_Period == "Islam Grčki (Hvar)" ~ paste0("Graduša Lokve \n Meat B + Fleece"),
      Site_Period == "Islam Grčki (Danilo)" ~ paste0("Graduša Lokve- \n", Site_Period, " Milk A"),
      Site_Period == "Smilčić (Impresso)" ~ paste0(Site_Period, " \n Milk B + Meat B"),
      Site_Period == "Smilčić (Danilo)" ~ paste0(Site_Period, " \n Milk A/B + Meat B"),
      str_detect(Site_Period, "Zemunik") ~ paste0(Site_Period, " \n Milk B + Meat B")
    )
  ) %>%
  select(Site_Period, strat.lab) %>% unique() %>% arrange(Site_Period)

strip_labels = setNames(c(strip.labeller$strat.lab), c(strip.labeller$Site_Period))

#-- create dataframe of Meat and Milk survivorship curves for plotting
strategies <- c("Meat", "Milk", "Milk B", "Milk A", "Meat B")

lx_values <- list(
  Meat   = c(85, 75, 70, 50, 30, 22, 10),
  Milk   = c(47, 42, 39, 35, 28, 18, 10),
  `Milk B` = c(83, 50, 36, 18, 6, 1, 1),
  `Milk A` = c(22, 11, 4, 3, 2, 1, 1),
  `Meat B` = c(86, 68, 28, 6, 1, 1, 1)
)

MilkMeatModels <- data.frame(
  Age = rep(unique(ages.df.correct$Age), times = length(strategies)),
  strategy = rep(strategies, each = length(unique(ages.df.correct$Age))),
  lx = unlist(lx_values, use.names = FALSE)
)

#-- Create Figure 2
Fig2 <- ages.df.correct  %>%
  ggplot() +
  geom_line(
    data = MilkMeatModels %>% filter(strategy == "Milk B" |
                                       strategy == "Milk A" | strategy == "Meat B") %>% mutate(lx = lx / 100),
    aes(
      group = strategy,
      x = Age,
      y = lx,
      linetype = strategy
    ),
    alpha = 0.5
  ) +
  scale_linetype_manual(
    values = c("twodash", "dotted", "dashed"),
    breaks = c("Milk A", "Milk B", "Meat B"),
    # breaks = c("Meat", "Milk"),
    name = "Strategy"
  ) +
  geom_col(data = ages.df.correct, aes(x = Age, y = fd.percent), alpha =
             0.8, ) +
  geom_line(
    data = ages.df.correct,
    aes(group = Site_Period, x = Age, y = s),
    alpha = 0.5,
    linewidth = 1,
    colour = "#2b8cbe"
  ) +
  geom_text(
    data = ages.df.correct,
    aes(
      x = Age,
      y = fd.percent,
      label = paste0(round(fd.percent * 100), "%")
    ),
    size = 3,
    vjust = -0.5
  ) +
  ylab("Percent Cumulative Frequency Distribution") + xlab("Age Class") +
  theme_minimal() +
  facet_wrap( ~ Site_Period, labeller = as_labeller(strip_labels, multi_line = TRUE)) +
  theme(
    axis.text.x = element_text(
      angle = 45,
      hjust = 1,
      size = 6
    ),
    strip.background = element_rect(fill = "#d9d9d980"),
    strip.text = element_text(size = 8),
    legend.position = "bottom"
  )

ggsave(
  plot = Fig2,
  filename = "Figures/Fig2_ArchaeologicalCullingStrategies.jpg",
  dpi = 300,
  width = 6,
  height = 4
)
```

```{r, plotFig2, echo=FALSE, fig.dim=c(6 , 4), fig.cap="Figure 2. Survivorship curves for archaeological culling strategies."}
Fig2
```

```{r, Table-3-site-survivorship, echo=FALSE, include=FALSE}
#-- Create Table of survival probabilities from culling data allocated to distribution of ages used in model
T3 = cbind.data.frame(c("", Payne_ages$ageClasses) ,
                      do.call(cbind.data.frame, args = c(culling.profiles)))
colnames(T3)[1] = "Age Class"


T3ft = flextable(T3[-1, ]) %>%
  colformat_double(digits = 2) %>%
  set_header_labels(ageClasses = "Age Class", Age = "Age (years)") %>%
  autofit() %>%
  set_table_properties(
    layout = "autofit",
    align = "center",
  ) %>%
  paginate(
    group = "Age Class",
    # keep Sample.ID group across pages
    group_def = "rle"
  ) %>%
  theme_vanilla()

T3ft = T3ft %>% set_caption("Table 3. Survival probabilities for caprines at four Neolithic Sites in Dalmatia.")

save_as_docx(T3ft, path = "tables/Table3_Site_survival_rates.docx", pr_section = sect_properties)

# rm(T3, T3ft)
```

```{r print-Table3, echo=FALSE}
T3ft %>% set_caption("Table 3. Survival probabilities for caprines at four Neolithic Sites in Dalmatia.")
```

```{r, set-colorpalatte, include=FALSE}
#-- set colorblind-friendly color palatte
cbPalette = carto_pal(10, "Safe")
```

```{r, Figure-S3.2-suvivorship-curves, echo=FALSE, fig.dim=c(6 , 4), fig.cap="Figure S3.2. Survivorship curves for archaeological culling strategies." }
#-- a function to plot survivorship curves
HerdDynamics::culling_multiplot(culling.profiles)
```

## Herd Population Growth Parameters

Offtake rates are used to calculate the number of animals slaughtered in each age group and are the primary constraint on population growth. Two other important parameters are **intrinsic mortality** and **fertility**. The fertility and mortality parameters are stored in the files `parameters.csv` and `prolificacy.csv` in the `data` folder.  

### Mortality 

The probability that an animal will survive from one time step to the next is influenced by the competing hazards of being slaughtered (i.e., offtake) and intrinsic mortality (i.e., due to disease, starvation, etc.). 

Different intrinsic mortality rates are applied to males and females. We apply mortality rates of 10% and 15% for males and females, respectively.  Male mortality is modeled slightly lower than female mortality since rams and bucks selected for breeding should be more robust and have better resistance to disease, whereas this artificial selection should be weaker for females. We simulate this via higher mortality for older females.


### Fertility - Reproduction Parameters
Several parameters are important regarding the reproductive biology of goats and sheep.
`pfbirth` specifies probability of giving birth to a female. This value is set as 0.5 by default in the code generating the parameter table.
`part.age` specifies the age of first parturition. , as an index corresponding to the age classes defined by `lclassf` and `lclassm`. By setting this variable to 4, we set the age of first parturition to 1 year.
`parturition` specifies the number of parturitions per female per year. Redding [-@Redding1981] models a breeding rate of once per year but notes that under conditions of very good pasturage goats may breed twice per year (1981:59). Parturition rate is also referred to as the annual reproductive rate (ARR) and is calculated as: $$ARR=\frac{l*365}{i}$$ where `l` is the litter size (i.e., prolificacy rate) multiplied by the number of days in the year and `i` is the parturition interval [@Upton1984ModelsOI; @Wilson1984].  To keep variation in fertility consistent, parturition varies from year to year, depending on the prolificacy rates, which are generated as described below. `parturitionInterval` is set to 300 days, reflecting a mean of 10 months for bot goats and sheep [@Wilson1989].

`prolificacy` specifies the prolificacy rate, defined as the number of live offspring per parturition per year. Goats are capable of giving birth to twins, triplets, and quadruplets, while kidding rates increase with age up to five or six years (Redding, 1981:70). To simulate stochastic inter-annual variation in fertility, a function is used to sample prolificacy rates from a normal distribution given mean kidding and lambing rates obtained from the literature. The `prolificacy.csv` file contains this data.

```{r, prolificacy-data, echo=TRUE}
#-- read in lambing and kidding rates
pro.dat = read.csv("data/prolificacy.csv")
#-- summarize prolificacy rates from the literature
NetPro = pro.dat %>% group_by(Taxon) %>% reframe(mn.pro = mean(LitterSize),
                                                 sd.pro = sd(LitterSize))
NetPro
```

The net fecundity rate is the product of the parturition and net prolificacy rates. The parturition rate is calculated differently for birth-pulse (all births occur at the same time) and birth-flow models (births occur continuously  over the time interval (t, t+1)). The Parturition rate `vpar` is dependent on the number of individuals removed from the herd, or `ptot` which is the sum of natural death rates and offtake rates:
$$vpar=\frac{1-ptot}{2}*hpar$$ 
where `hpar` is the number of parturitions expected per female-time unit. 

```{r, fertility-mortality-data, echo=FALSE}
#-- read in parameters file for mortality, prolificacy, and parturition rates
param.dat = read.csv("data/parameters2.csv")
```

Using the mortality and prolificacy data called in the previous chunk two lists are created (one for goats, one for sheep) containing the fertility and mortality parameters used to compute **lambda** ($\lambda$), reproductive values, and project herd growth. The function `generate_prolificacy_rates()` is used to vary inter-annual fertility values. This function and `generate_infant_mortality_rates` are included in HerdDynamics package.

The above function is used in this chunk to generate a series of prolificacy rates based on fertility data. Also defined is the function `Part.rate` which calculates $ARR$.
```{r, ARR, echo=TRUE}
#-- function to calculate annual reproduction rate (ARR), included in HerdDynamics package 
ARR = function(mean_litter_size, parturition_interval) {
  (mean_litter_size * 365) / parturition_interval
}
```

```{r, parm-lists, echo=TRUE}
#-- function to get vector of age structured mortality rates for male and female goats and sheep
get_mortality <- function(taxon, sex) {
  param.dat %>%
    filter(Taxon == taxon, Sex == sex) %>%
    pull(Mortality)
}

#-- Ages, parturition interval, and age of first parturition set here
ages = HerdDynamics::Payne_ages$ages  # unique(param.dat$Age)
parturition.Interval = 300 
part.age = 2


#-- create parms lists
goat.parms = list(
  ages = ages,
  parturition = ARR(NetPro$mn.pro[1], parturition.Interval),
  # calculates annual reproduction rate
  parturition.Interval = parturition.Interval,
  part.age = part.age,
  MeanProlificacy = NetPro$mn.pro[1],
  sdProlificacy = NetPro$sd.pro[1],
  f.mortality = get_mortality("Goat", "Female"),
  m.mortality = get_mortality("Goat", "Male")
)

sheep.parms = list(
  ages = ages,
  parturition = ARR(NetPro$mn.pro[2], parturition.Interval),
  # calculates annual reproduction rate
  parturition.Interval = parturition.Interval,
  part.age = part.age,
  MeanProlificacy = NetPro$mn.pro[2],
  sdProlificacy = NetPro$sd.pro[2],
  f.mortality = get_mortality("Sheep", "Female"),
  m.mortality = get_mortality("Sheep", "Male")
)
```

```{r, Table1-parameters, include=FALSE}
set.seed(388)
#-- generate Prolificacy rates for Table 1 using function above
param.dat$Prolificacy[param.dat$ParturitionRate > 0 &
                        param.dat$Taxon == "Goat"] = generate_prolificacy_rates(meanPro = NetPro$mn.pro[1],
                                                                                sdPro = NetPro$sd.pro[1],
                                                                                n = 6)
param.dat$Prolificacy[param.dat$ParturitionRate > 0 &
                        param.dat$Taxon == "Sheep"] = generate_prolificacy_rates(meanPro = NetPro$mn.pro[2],
                                                                                 sdPro = NetPro$sd.pro[2],
                                                                                 n = 6)

#-- calculate Parturition Rates basead on prolificacy for Table 1
param.dat$ParturitionRate <-  ARR(param.dat$Prolificacy, parturition.Interval)




#-- create Table 1 of parameters used in Lefkovitch matrix
t1 = as_grouped_data(
  param.dat %>%
    mutate("Parturition Rate" = ParturitionRate) %>%
    select(Taxon, Age, Sex, "Parturition Rate", Prolificacy, Mortality) %>%
    pivot_wider(
      names_from = c(Sex),
      values_from = c("Parturition Rate", Prolificacy, Mortality)
    ) %>%
    select(
      Taxon,
      Age,
      `Parturition Rate_Female`,
      Prolificacy_Female,
      contains("Mortality")
    ),
  groups = "Taxon"
) 


t1 = as_flextable(t1) %>%
  separate_header() %>%
  bold(
    j = 1,
    i = ~ !is.na(Taxon),
    bold = TRUE,
    part = "body"
  ) %>% # make Taxon bold
  bold(part = "header", bold = TRUE) %>%  # make headers bold
  colformat_double(j = c(4, 5), digits = 3) %>% # set mortality column to 3 digits
  colformat_double(j = c(2, 3), digits = 2) %>%
  autofit() %>%
  set_table_properties(
    layout = "autofit",
    align = "center",
    # opts_word = list("split" = FALSE, "keep_with_next" = TRUE)
  ) %>%
  paginate(
    group = "Taxon",
    # keep Sample.ID group across pages
    group_def = "rle"
  ) %>%
  theme_vanilla() %>%
  align(j = 1, align = "left")

t1


#-- properties for word doc output
sect_properties <- prop_section(
  page_size = page_size(
    orient = "portrait",
    width = 8.5, height = 11
    ),
  type = "continuous",
  page_margins = page_mar(left = 1)
)

t1 %>% set_caption(
  "Table 1. Parameters used to construct the Lefkovitch population projection matrix for sheep and goats. Parturition and prolificacy rates one possible outcome of the sampling procedure."
)
#-- create output word doc
save_as_docx(t1, path = "./tables/Table1_parameters.docx", pr_section = sect_properties)
# rm(t1)

```

## Build Lefkovitch matrix

Now that the mortality, offtake, and fertility parameters have been defined, it's time to create the Lefkovitch matrix. The first step is to convert the survivorship percentages to mortality probabilities. This is done by dividing each value by 100 and subtracting from 1. A **Baseline** strategy is also created to track herd population dynamics free from the offtake constraint by setting survivorship probability to 100% which translates to an offtake rate of 0 for each age group. 

In the chunk below, `Baseline.offtake` is created as a list of 100% survivorship for all age classes to model herd growth with no offtake. The list is appended to the list of all offtake models to be run in the subsequent projections.

```{r, offtake-survivorship}
#-- create Baseline offtake (no offtake, 100% survivorship)
Baseline.offtake = list(Baseline = rep(100, length(offtake_models$Energy)))

#-- put all culling strategies into a single list
all.offtake <-  c(offtake_models, culling.profiles, Baseline.offtake)

#-- convert survivorship to mortality probabilities
offtake.mortality = lapply(all.offtake, function(x) {
  1 - (x / 100)
})

```

Next, a list named `param.props` containing all the  parameters defined above, the original `tcla` table, `nbphase`, and a female offtake modifier, `female.offtake` is created. The list is supplied to the `build.param` function which streamlines the creation of the hazards table and Lefkovitch matrix used by `mmage` to project population changes. The variable `female.offtake` is supplied (or not, if set to `NULL`) to adjusts the female offtake rate. Setting `female.offtake` to 0 implies that females exit the herd only through natural deaths and eliminates all variation between different culling strategies models with respect to herd growth and defeats the purpose of this experiment. `female.offtake` is therefore set to `15` reflecting a culling rate of females due to infertility reported by Malher et al. [-@Malher2001].


```{r, CombineParams, echo=TRUE}
#-- This number is used to account for culling of females due to infertility. If Null, no female offtake assumed.
female.offtake = 15

sheep.param.props = list(
  tcla = tcla,
  parms = sheep.parms,
  nbphase = nbphase,
  female.offtake = female.offtake
)

goat.param.props = list(
  tcla = tcla,
  parms = goat.parms,
  nbphase = nbphase,
  female.offtake = female.offtake
)

param.props = list(goat = goat.param.props, sheep = sheep.param.props)
```

The  `vary.fert.mort()` function produces new sets of prolificacy and fertility rates using `HerdDynamics::generate_prolificacy_rates()` and `HerdDynamics::generate_AdultMortalityRates()`, which sample from a normal distribution of mean and standard deviations provided in `parms`. The function will run each time a new parameter table is created to simulate inter-annual variation in fertility and mortality.

```{r, varyfert_mort}
set.seed(123)
#-- function to vary prolificacy and mortality
vary.fert.mort = function(parms, n = 6) {
  parms$prolificacy = generate_prolificacy_rates(
    meanPro = parms$MeanProlificacy,
    sdPro = parms$sdProlificacy,
    n = n
  )
  
  #-- vary parturition rate
  # parms$parturition = ARR(mean(parms$prolificacy), parms$parturition.Interval)
  parms$parturition = ARR(parms$prolificacy, parms$parturition.Interval)
  
  generate_AdultMortalityRates <- function(Mort = f.mortality, n = 6) {
    adult.mort = Mort[4:length(Mort)]
    sort(generate_prolificacy_rates(
      meanPro = mean(adult.mort),
      sdPro = sd(adult.mort),
      n = 6
    ),
    decreasing = FALSE)
  }
  
  #-- update male and female mortality rates
  parms$f.mortality = c(
    generate_infant_mortality_rates(parms$f.mortality),
    generate_AdultMortalityRates(parms$f.mortality)
  )
  
  parms$m.mortality = c(
    generate_infant_mortality_rates(parms$m.mortality),
    generate_AdultMortalityRates(parms$m.mortality)
  )
  return(parms)
}
```

Here is an example of the parameters used for a single year.
```{r, varyfert_mort-example, echo=TRUE}
#-- example of parameters created for a single year.
vary.fert.mort(parms = goat.parms)
```

### Create Parameter Tables for Each Culling Strategy
Here a single param table is created for each survivorship profile in **two steps**. 

**First**, the parms object is updated with prolificacy and infant mortality rates generated by sampling from a normal distribution using the `vary.fert.mort()` function defined above. 

**Second**, build_param function is run which creates a table that contains offtake, mortality, fecundity, and survival probabilities for each age class


```{r, Lefkovich-matrix}
#-- create param table for each offtake strategy with varying fertility and mortality
set.seed(542)
param = lapply(param.props, function(p) {
  p$parms = vary.fert.mort(p$parms)
  lapply(offtake.mortality, function(o) {
    with(p , {
      build_param(
        tcla,
        parms,
        nbphase,
        female.offtake,
        correctionfec = TRUE,
        offtake = o
      )
    })
  })
})

str(param$goat$Energy$param)
```
```{r, clean-up, include=FALSE}
rm(sheep.param.props, goat.param.props, Baseline.offtake)

```

The example above creates a list of parameter tables for each offtake strategy for both goats and sheep with varying fertility and mortality parameters for a single year. In the next part, these tables will be used to simulate environmental variation over multiple years.

# Part II - Simulating Environmental Variation

In the previous chunk, the function `build.param()` was run to produce a parameter set using auto-generated prolificacy rates and infant mortality rates using mean and standard deviation for each taxon. 

In this chunk, environmental variation is simulated by creating a new `param` table for each time-step containing unique sets of fertility and mortality parameters using the `vary.fert.mort()` function described above. This is done using the `make.listpar()` function which has the `vary.fert.mort()` function built into it. The function simulates a single environment with unique fertility and mortality rates while keeping the offtake rates defined earlier constant. The environment is called `listpar`. The number of years over which the simulation will run is specified by `nbcycle`.

```{r, Environment-list, eval=TRUE}
source("./R/makeListpar.R")
#-- make.listpar definition
make.listpar = function(param.props, nbcycle, offtake.mortality) {
  with(param.props, {
    #-- get number of timesteps
    nbstep = nbcycle * nbphase
    #-- create list of parms
    parms.rep = replicate(n = nbstep,
                          vary.fert.mort(parms = parms),
                          simplify = FALSE)
    #-- create listpar
    lapply(offtake.mortality, function(o) {
      lapply(parms.rep, function(p) {
        build_param(
          tcla = tcla,
          parms = p,
          offtake = o,
          female.offtake = female.offtake,
          correctionfec = TRUE,
          nbphase = nbphase
        )$param
      })
    })
  })
}
```

## Generate Stochastic Environment
Using the functions defined above, a stochastic environment is created for each offtake strategy. The function `make.listpar()` is run with the parameters defined above. The number of cycles is set to `200` and the initial population size is set to `150`.

```{r, Stochastic-environment, echo=TRUE, eval=TRUE}
set.seed(600)
#-- set number of cycles and initial population size
nbcycle = 200
p0 = 150

#-- uncomment lines below to re-create simulation environment or use existing by loading from data folder
listpar = lapply(param.props, function(p) {
  make.listpar(
    param.props = p,
    nbcycle = nbcycle,
    offtake.mortality = offtake.mortality
  )
})

#-- save stochastic environment to replicate results
save(listpar, file = "data/listpar.RData")
load(file = "data/listpar.RData")
```

## Basic Herd structure and growth
With the fertility and mortality rates have been established the next step is to extract the structure of the herd, lambda, and the proportion of male to females for each model. To do this, an initial herd size, `p0` is set to `150`. In the following chunk, these traits are calculated for comparison of the impacts of culling strategies on herd demography. 

While lambda can be computed from a single `param` table, the herd multiplication rate will change from one time-step to the next as fertility and mortality rates change. To estimate lambda given this variation a bootstrapping procedure is used. 

Using the list of mortality and fertility parameters created in the previous chunk, the custom function `getLambda()` is run using `lapply` to obtain lambda, sex proportion, and number of individuals in each age class for the initial population. This function is a wrapper function that uses functions in the `mmage` package to obtain the dominant eigenvalue $/lambda$  to get the multiplication rate for the population.

With the environment simulated as `listpar`, the chunk below calculates lambda and proportion of females for each year under each offtake strategy.
```{r, Lambda-sex-proportion, cache=TRUE, echo=TRUE}
#-- wrapper function to get demography information from every listpar table
wrapper.repro = function(listpar, out = c("lambda", "sex")) {
  out <- match.arg(out)
  lapply(seq_along(listpar), function(l) {
    p = listpar[[l]]
    lapply(p, function(s) {
      sapply(s, function(x) {
        r = get_lambda(x, tcla = tcla, p0 = p0) #$lambda
        if (out == "lambda") {
          return(r$lambda)
        } else {
          if (out == "sex") {
            return(r$sex.proportion[1, 2])
          }
        }
      })
    })
  })
}

#-- put all lambda and female proportions in lists
lambda.list = wrapper.repro(listpar, out = "lambda")
sex.prop.list = wrapper.repro(listpar, out = "sex")
#-- assign names to each list
names(lambda.list) <- names(sex.prop.list) <- names(listpar)
#-- unlist each list
lambda.list = unlist(lambda.list, recursive = F)
sex.prop.list = unlist(sex.prop.list, recursive = F)
```

### Bootstrap lambda and sex proportions

This chunk defines the function used in the bootstrap estimation of mean $\lambda$ ($\lambda_{boot}$)  and proportion of females. The bootstrap is replicated 1000 times. The output is `repro.boot.df`.

```{r, Bootstrap, echo=TRUE}
set.seed(665)
#-- Define function to calculate the mean
mean_function <- function(data, indices) {
  # This function will be applied to resampled data
  return(mean(data[indices]))
}

#-- function to compute bootstrapped mean and 95% confidence intervals
boot.fun = function(s, n) {
  # Perform bootstrapping
  bootstrap_results = boot(data = s,
                           statistic = mean_function,
                           R = n)
  # Obtain bootstrapped confidence interval
  boot_conf_interval = boot.ci(bootstrap_results, type = "perc")
  #-- returns mean, lower and upper ci
  return(
    data.frame(
      t0 = boot_conf_interval$t0,
      low = boot_conf_interval$percent[4],
      up = boot_conf_interval$percent[5]
    )
  )
}

#-- set number of bootstrap replicates
n.boot = 1000

lambda.boot.df = do.call(rbind.data.frame, lapply(lambda.list, FUN = boot.fun, n = n.boot))
sex.prop.boot.df = do.call(rbind.data.frame, lapply(sex.prop.list, function(l) {
  s = unlist(l)
  boot.fun(s, n.boot)
}))

#-- create taxon and strategy columns
taxon.strat = str_split(rownames(lambda.boot.df), "\\.", simplify = T)

#-- bind columns from each bootstrapped results table
repro.boot.df = cbind.data.frame(
  lambda.boot.df %>%
    reframe(
      Taxon = taxon.strat[, 1],
      strategy = taxon.strat[, 2],
      Lambda = t0,
      low.lambda = low,
      up.lambda = up
    ),
  sex.prop.boot.df %>%
    reframe(
      "Proportion.Female" = t0,
      "Proportion.Male" = 1 - t0,
      low.sex.F = low,
      up.sex.F = up
    )
)
#-- view first six rows of results
head(repro.boot.df[, 1:6])
```

```{r write-reproboot-results, echo=FALSE, include=FALSE}
write.table(repro.boot.df, file = "output/reproboot.csv", sep = ",")
#-- clean up environment
# rm(lambda.list, sex.prop.list, sex.prop.boot.df)
```

```{r lambda-plot, echo=FALSE, fig.dim=c(6 , 4), fig.cap="Figure S3.3. Bootstrapped estimates of lambda ($\\lambda_{boot}$) for each culling strategy showing 95% confidence intervals. A horizontal dashed line at $\\lambda$ = 1 indicates stable population growth." }
#-- Plot bootstrapped lambda results
Fig3 = repro.boot.df %>%
  mutate(strategy = factor(strategy, levels = repro.boot.df$strategy[1:16])) %>%
  ggplot(aes(x = strategy, y = Lambda, color = Taxon)) +
  geom_hline(yintercept = 1,
             linetype = "dashed",
             color = cbPalette[10]) +
  geom_point(size = 2,
             position = position_dodge(width = 0.5),
             alpha = 0.8) +
  geom_errorbar(aes(ymin = low.lambda, ymax = up.lambda),
                width = 0.5,
                position = "dodge") +
  scale_color_manual(values = cbPalette[c(1, 2)]) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

Fig3

#-- save figure
ggsave(
  Fig3,
  filename = "./Figures/Fig3_lambda-boot.jpg",
  dpi = 300,
  width = 6,
  height = 4
)
```

```{r, Loadreproboot-results, include=FALSE}
repro.boot.df = read.table("output/reproboot.csv", header = T, sep = ",")
```


```{r, Lambda-Boot-Table, include=FALSE}
#-- This chunk creates table using flextable showing the bootstrapped lambda and herd proportion values
colnames(repro.boot.df)[c(6, 7)] = c("Proportion Female", "Proportion Male")

#-- create table 3 (theoretical harvest profiles)
t4 = repro.boot.df %>%
  filter(!strategy %in% names(culling.profiles)) %>%
  select(Taxon, strategy, Lambda, "Proportion Female", "Proportion Male") %>%
  pivot_longer(cols = c(3:5)) %>%
  pivot_wider(names_from = c(strategy))

#-- create table 4 (empirical harvest profiles)
t5 = repro.boot.df %>%
  filter(strategy %in% names(culling.profiles)) %>%
  select(Taxon, strategy, Lambda, "Proportion Female", "Proportion Male") %>%
  pivot_longer(cols = c(3:5)) %>%
  pivot_wider(names_from = c(strategy))

#-- function for formatting these two flextables
lambda.tables = function(tab) {
  tf = as_grouped_data(tab, groups = "Taxon")
  as_flextable(tf) %>%
    separate_header() %>%
    set_header_labels(
      name = "",
      MeatA = "Meat A",
      MeatB = "Meat B",
      MilkA = "Milk A",
      MilkB = "Milk B"
    ) %>%
    bold(
      j = 1,
      i = ~ !is.na(Taxon),
      bold = TRUE,
      part = "body"
    ) %>% # make Taxon bold
    bold(part = "header", bold = TRUE) %>%  # make headers bold
    colformat_double(i = c(2, 6), digits = 3) %>%
    colformat_double(i = c(3, 4, 7, 8), digits = 2) %>%
    autofit() %>%
    set_table_properties(layout = "autofit", align = "center") %>%
    paginate(
      group = "Taxon",
      # keep Sample.ID group across pages
      group_def = "rle"
    ) %>%
    theme_vanilla() %>%
    align(j = 1, align = "left")
}

#-- view table
t4 = lambda.tables(t4)
t5 = lambda.tables(t5)
t4
t5

#-- properties for word doc output
sect_properties <- prop_section(
  page_size = page_size(
    orient = "landscape",
    width = 8.5,
    height = 11
  ),
  type = "continuous",
  page_margins = page_mar(top = 1)
)

#-- create output word doc
save_as_docx(t4, path = "tables/Table4_lambda_theory.docx", pr_section = sect_properties)
save_as_docx(t5, path = "tables/Table5_lambda_culling.docx", pr_section = sect_properties)

```

Tables 4 and 5 show the bootstrapped estimates of $\lambda_{boot}$ and proportion of males and females in the herd for each culling strategy.
```{r, Table4-lambda-theory, echo=FALSE}
t4
```
```{r, Table5-lambda-culling, echo=FALSE}
t5
```

$\lambda_{boot}$ and proportion of females in the herd are negatively correlated.  
```{r, Lambda-Female-corr, echo=FALSE, eval=TRUE}
#-- check correlation between lambda and sex proportions
repro.boot.df %>% filter(strategy != "Baseline") %>% with(cor.test(Lambda, `Proportion Female`, method = "pearson"))

```

```{r, strip-labeler, include=FALSE}
#-- This chunk defines a function used to label facet strips with lambda-boot
#-- create label data frame
strip.labeller = lambda.boot.df %>%
  mutate(
    taxon = str_split_i(rownames(lambda.boot.df), "\\.", 1),
    strategy = str_split_i(rownames(lambda.boot.df), "\\.", 2),
    lambda = round(t0, 3)
  ) %>%
  select(taxon, strategy, lambda) %>%
  pivot_wider(names_from = taxon, values_from = lambda) %>%
  mutate(
    strat.lab = case_when(
      strategy == "MeatA" ~ "Meat A",
      strategy == "MeatB" ~ "Meat B",
      strategy == "MilkA" ~ "Milk A",
      strategy == "MilkB" ~ "Milk B",
      .default = strategy
    )
  ) %>%
  mutate(lambda.lab = case_when(
    goat != sheep ~ paste0(
      strat.lab,
      "\n (",
      format(goat, nsmall = 3),
      "; ",
      format(sheep, nsmall = 3),
      ")"
    ),
    .default = paste0(strat.lab, "\n (", format(goat, nsmall = 3), ")")
  )) %>%
  select(strategy, lambda.lab)

#-- create labeller
strip_labels = setNames(c(strip.labeller$lambda.lab), c(strip.labeller$strategy))
```


```{r, plot-sex-proportion, echo=FALSE, fig.dim=c(6 , 4), fig.cap="Figure S3.4. Proportion of females and males for each strategy"  }
#-- This chunk creates a plot showing the proportion of females and males in the herd based on the bootstrapped estimates of sex proportions.
repro.boot.df %>%
  select(Taxon, strategy, Lambda, `Proportion Female`, `Proportion Male`) %>%
  # select(Taxon, strategy, Lambda, Proportion.Female, Proportion.Male) %>%
  pivot_longer(cols = c(4, 5)) %>%
  mutate(
    Lambda = round(Lambda, 3),
    # Sex = case_when(name == "Proportion.Female" ~ "F",
    # name == "Proportion.Male" ~ "M"),
    Sex = case_when(name == "Proportion Female" ~ "F", name == "Proportion Male" ~ "M"),
    strategy = factor(strategy, levels = c(names(offtake.mortality)))
  ) %>%
  mutate(Strat = paste0(strategy, " (λ=", Lambda, ")")) %>%
  ggplot() +
  geom_col(aes(x = Sex, y = value, fill = Taxon), position = "dodge") +
  ylab("Proportion") +
  scale_fill_manual(values = cbPalette) +
  theme_minimal()  +
  facet_wrap(~ strategy , labeller = as_labeller(strip_labels))
```

## Herd Structure
This chunk calculates herd structure which is used to produce Figure 4.
```{r, herd-structure}
#-- set initial population size
p0 = p0

#-- call function getLambda to extract reproduction traits
repro = lapply(listpar, function(l) {
  lapply(l, function(x) {
    get_lambda(x[[1]], tcla = tcla, p0 = p0)
  })
})
#-- age classes vector for plotting
ageClasses = c("", Payne_ages$ageClasses)

#-- wrapper function to get a dataframe with herd structure from repro object
xini.to.data.frame = function(repro, ageClasses, ages) {
  xini.list = lapply(repro, function(r) {
    # given repro, a list of reproductive params for n species,
    lapply(r, function(x) {
      with(x, {
        # summarize initial herds (total males and females for each age class)
        xini = initial.herd %>%
          group_by(class) %>%
          reframe(n = as.integer(sum(xini)))
      })
    })
  })
  xini.list = unlist(xini.list, recursive = F) # unlist species groupings
  taxon.strat = str_split(names(xini.list), "\\.") # create list of species and strategies
  # create Taxon, strategy, and AgeClass fields for each df in xini.list
  for (i in 1:length(xini.list)) {
    ts = taxon.strat[[i]]
    taxon = rep(unlist(ts)[1], 9)
    strat = rep(unlist(ts)[2], 9)
    xini.list[[i]]$Taxon = taxon
    xini.list[[i]]$strategy = strat
    xini.list[[i]]$AgeClass = ageClasses[-1]
    xini.list[[i]]$Age = as.character(ages)
  }
  # call all dataframes into a single df
  xini.df = do.call(rbind.data.frame, xini.list)
  # make strategy field a factor
  xini.df$strategy = factor(xini.df$strategy, levels = c(names(offtake.mortality)))
  xini.df$AgeClass = factor(xini.df$AgeClass, levels = ageClasses[-1])
  return(xini.df)
}

xini.df = xini.to.data.frame(repro, ageClasses = ageClasses, ages = ages)
head(xini.df)
```

Plot herd structure for each culling strategy showing number of animals in each age class for goats and sheep.
```{r Figure4, echo=FALSE, fig.dim=c(6,4), fig.cap="Figure S3.5. Herd structure for each culling strategy showing number of animals in each age class for goats and sheep." }
#-- This chunk creates Figure 4 in the article, showing herd structure for each strategy
Fig4 = xini.df %>% filter(n > 0) %>%
  ggplot() +
  # geom_col( aes( x = AgeClass, y = n, fill = Taxon ), position = "dodge" ) +
  geom_col(aes(x = Age, y = n, fill = Taxon), position = "dodge") +
  scale_fill_manual(values = cbPalette, labels = c("Goat", "Sheep")) +
  # xlab( "Age Class" ) +
  xlab("Age (years)") +
  ylab("Number of Animals") +
  # scale_y_continuous( breaks = c(0, 25, 50)) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(hjust = 1, size = 8),
    axis.text.y = element_text(size = 8),
    line = element_line(linewidth = 0.2),
    legend.position = "bottom"
  ) +
  facet_wrap(~ strategy, labeller = as_labeller(strip_labels)) #  strip_labeller )

Fig4
ggsave("Figures/Fig4_herd_structure.jpg",
       Fig4,
       dpi = 300,
       width = 6,
       height = 4)
```

# Part III - Population Projection

The next step is to simulate herd demographic change through time given the parameters defined above and the reproductive traits calculated for each model and culling profile. The initial herd size of 150 was established already as `p0` and the simulated environment as `listpar`. The number of timesteps is equal to the length of `listpar`. 

The projection is run using the function `projectHerd2()`, which is a wrapper function that streamlines the herd projection procedure described in the mmage documentation [@mmage] but is used when the environment is predefined. The alternative is  `HerdDynamics::projectHerd()` is useful when there is only one `param` table but environmental variation is generated for each time-step (See HerdDynamics documentation). 

The projection is run for every strategy using the mortality and fertility rates for each taxon using `lapply`, the output is `results`, a list of length n.strategies * n.taxa.

```{r, project-herd, echo=TRUE}
#-- load projectHerd function
source("./R/projectHerd2.R")

#-- project herd for each strategy
listpar = unlist(listpar, recursive = F)
results = lapply(listpar, function(l) {
  projectHerd2(listpar = l, p0 = p0)
})
```

## Output Metrics

Here we gather the results into a data.frame to produce plots and compare how the different models perform (i.e., values that will be used to compare differences in herd size, etc.).

First, a wrapper function is defined as `pop.summary2()`, which takes and creates a list of data.frames from `results`, each containing two columns: `time` and `pop`(ulation). `pop.summary2()` has the option of tracking population by sex.  

A second wrapper function, `res.to.df()` is defined to combine the list into a single data.frame which we use for plotting.

```{r, helper functions to summarize-Total-Pop-Outputs, echo=TRUE}
#-- function to summarize dynamics of the total population through time
pop_summary2 = function(x, sex = FALSE, interval = "year") {
  vecx = x$vecx
  if (interval == "month") {
    if (sex) {
      out = aggregate(x ~ tim + sex , data = vecx, FUN = sum)
      colnames(out) = c("time", "sex", "pop")
    } else {
      out = aggregate(x ~ tim, data = vecx, FUN = sum)
      colnames(out) = c("time", "pop")
    }
  }
  if (interval == "year") {
    if (sex) {
      out = aggregate(x ~ cycle + sex , data = vecx, FUN = sum)
      colnames(out) = c("time", "sex", "pop")
    } else {
      out = aggregate(x ~ cycle , data = vecx, FUN = sum)
      colnames(out) = c("time", "pop")
    }
  }
  return(out)
}

#-- function to gather results into a single data.frame
res.to.df = function(tot.pop.res) {
  df = do.call(rbind.data.frame, args = c(tot.pop.res, make.row.names = FALSE))
  strats = names(tot.pop.res)
  df$strategy = unlist(lapply(strats, FUN = rep, (nrow(df) / length(strats))))
  ts = str_split(df$strategy, "\\.", simplify = T)
  df$Taxon = ts[, 1]
  df$strategy = ts[, 2]
  return(df)
}
```

Run helper functions to gather results into a single data.frame
```{r, summarize-Total-Pop-Outputs, echo=TRUE}
#-- summarize total population through time
tot.pop.res = lapply(results, function(r) {
  pop_summary2(r, sex = FALSE, interval = "year")
})
tot.pop.df = res.to.df(tot.pop.res)
#-- uncomment to get results by sex
# tot.pop.res.sex = lapply(results, function(r){pop.summary(r, sex = TRUE, interval = "year")})
# tot.pop.df.sex = res.to.df(tot.pop.res.sex)

head(tot.pop.df)
# head(tot.pop.df.sex)
```


```{r, Fig6, echo=FALSE, warning=FALSE, fig.dim=c(6,4), fig.cap="Figure. S3.6. Plots showing the change in sheep and goat herd sizes through time under the various culling strategies used. " }


#-- plot
Fig5 = tot.pop.df %>%
  mutate(Taxon = factor(Taxon, levels = c("goat", "sheep"))) %>%
  mutate(strategy = factor(strategy, levels = c(names(offtake.mortality))))  %>%
  ggplot() +
  geom_col(aes(time, pop, fill = Taxon), alpha = 0.8) +
  scale_fill_manual(
    breaks = c("goat", "sheep"),
    values = cbPalette[c(1, 2)],
    labels = c("Goat", "Sheep")
  ) +
  labs(x = "Time (years)", y = "Number of animals") +
  facet_wrap(~ strategy,
             labeller = as_labeller(strip_labels),
             scales = "free_y") +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    line = element_line(linewidth = 0.2),
    axis.text = element_text(size = 6),
    strip.text = element_text(size = 8)
  )

Fig5

ggsave(
  "Figures/Fig5_projections.jpg",
  plot =  Fig5,
  dpi = 300,
  width = 6,
  height = 4
)

```

## Stochastic variation

Since there is an element of stochastic variation, it is useful to examine multiple iterations of the simulation. 

To do this, we define a wrapper function, `stochastic.rep()` and use `replicate()` run the simulation 10 times. Results are combined into a `data.frame` for plotting using `matrix.to.df` and `list.to.mat`. 
```{r, replicate helpers, echo=TRUE}
#-- function to replicate
stochastic.rep = function(p0,
                          param.props,
                          offtake.mortality,
                          nbcycle) {
  #-- create new set of environmental parameters
  lp = make.listpar(
    param.props = param.props,
    nbcycle = nbcycle,
    offtake.mortality = list(offtake.mortality)
  )
  #-- reproject herd growth
  result = projectHerd2(listpar = unlist(lp, recursive = F) , p0 = p0)
  #-- summarize results
  pop_summary2(result, sex = FALSE, interval = "year")$pop
}

#-- helper function to transform lists into matrix
list.to.mat = function(l) {
  n.col = length(l)
  l.mat = matrix(unlist(l), ncol = n.col)
  rownames(l.mat) = unique(names(unlist(l)))
  l.mat
}

#-- helper function to create df from matrix output of replicated stochastic.rep function
matrix.to.df = function(mat) {
  df = as.data.frame(mat)
  df$time = as.numeric(str_replace_all(rownames(df), "[:alpha:]|[:punct:]", ""))
  df$strategy = str_replace_all(rownames(df), "[:digit:]", "")
  df %>% pivot_longer(cols = c(-time, -strategy))
}
```

Run replicated simulations
```{r, run-replicates, echo=TRUE, cache=TRUE}
#-- set seed, number of replicates and cycles
set.seed(1056)
nbrep = 10
nbcycle = nbcycle

#-- run simulation for all strategies
stochastic.sim.res = replicate(n = nbrep,
                               lapply(param.props, function(p) {
                                 lapply(offtake.mortality, function(o) {
                                   r = stochastic.rep(
                                     p0 = p0,
                                     param.props = p,
                                     offtake.mortality = o,
                                     nbcycle = nbcycle
                                   )
                                 })
                               }),
                               simplify = "array")

#-- create matrix, then df from results
sto.res.mat = apply(stochastic.sim.res, 1, FUN = list.to.mat, simplify = F)
sto.res.df = lapply(sto.res.mat, FUN = matrix.to.df)

#-- set taxon fields
sto.res.df$goat$taxon = "goat"
sto.res.df$sheep$taxon = "sheep"

#-- combine into one df
sto.res.df = do.call(rbind.data.frame, sto.res.df)
sto.res.df$strategy = factor(sto.res.df$strategy, levels = c(names(offtake.mortality)))

```

Plot the results of the replicated stochastic simulations.
```{r, Figure7, warning=FALSE, echo=FALSE, fig.dim=c(6,4), fig.cap="Figure. S3.7. Plots showing results of replicated projections of change in sheep and goat herd sizes through time under the various survivorship profiles used." }
#-- plot results
Fig7 = sto.res.df %>%
  mutate(Taxon = taxon) %>%
  ggplot(aes(group = name)) +
  geom_line(
    data = . %>% filter(Taxon == "sheep"),
    aes(x = time, y = value , color = Taxon),
    lwd = 0.2,
    alpha = 0.8
  ) +
  geom_line(
    data = . %>% filter(Taxon == "goat"),
    aes(x = time, y = value, color = Taxon),
    lwd = 0.2,
    alpha = 0.8
  ) +
  scale_color_manual(values = cbPalette) +
  ylab("Number of Animals") +
  xlab("Year") +
  scale_color_manual(
    breaks = c("goat", "sheep"),
    values = cbPalette[c(1, 2)],
    labels = c("Goat", "Sheep")
  ) +
  theme_minimal() +
  facet_wrap(~ strategy,
             scales = "free_y",
             labeller = as_labeller(strip_labels)) +
  theme(
    strip.text = element_text(size = 8),
    axis.text = element_text(size = 6),
    legend.position = "bottom",
    line = element_line(linewidth = 0.2)
  )
Fig7

ggsave(
  "Figures/Fig6_stochastic_rep.jpg",
  plot =  Fig7,
  dpi = 300,
  width = 6,
  height = 4
)

rm(stochastic.sim.res, sto.res.mat)
```

# Part IV - Optimizing Culling Rates
In this section we explore whether modifying culling rates can result in stable herd sizes. 

We do this by creating an optimization algorithm to determine the factor, $\varphi$, by which female offtake rates need to be adjusted to prevent changes in the herd growth rate from one time step from the next. The goal is to achieve a steady state multiplication rate under stochastic changes in fertility and mortality. 

## Define objective function
We begin by defining the function `get.off.adjust.poff()`, which takes as input a `param` table and a value of $\varphi$ and returns the squared difference between the projected multiplication rate, $\lambda$, and the target multiplication rate, $m$ (set to 1 for stable population growth).

```{r, direct-constraints, echo=TRUE}
#-- function to adjust offtake based on poff in param table
get.off.adjust.poff = function(phi, param.ref, m = 1) {
  u = param.ref
  zf = u$poff[u$sex == "F"]
  zm = u$poff[u$sex == "M"]
  u$poff = c(phi * zf, zm)
  Lf = length(u$sex[u$sex == "F"]) - 1
  Lm = length(u$sex[u$sex == "M"]) - 1
  param = u
  A = mmage::fmat(param, Lf, Lm)$A
  (mmage::feig(A)$lambda - m)^2
}

```


## Optimize
In this chunk, the function `stats::optimize()` uses the adjustment function defined above to find $\varphi_{opt}$, the value that will be used to adjust female offtake rates in a new projection.

```{r, optimize, echo=TRUE}
#-- optimize to find the value that minimizes (lambda-m)^2 (i.e., difference between projected herd growth rate and objective growth)
#-- an example of optimized phi
optimize(
  f = get.off.adjust.poff,
  param.ref = listpar$goat.Energy[[1]],
  interval = c(0, 5)
)$minimum

#-- optimize for all years in the Energy strategy for goats, as an example.
optimize.res = lapply(listpar$goat.Energy, function(b) {
  optimize(f = get.off.adjust.poff,
           param.ref = b,
           interval = c(0, 5))$minimum
})

#-- phi
optimize.res[1:5]

```

### Dynamic optimization function
Now that the optimization algorithm has been demonstrated for one set of parameters, a wrapper function is defined that will dynamically adjust offtake rates by $\varphi_{opt}$ when $\lambda <$ `low.threshold` or $\lambda \ge$ `high.threshold`. 

```{r, adjust-offtake-fun, echo=TRUE}
#-- function for adjusting p. female offtake
adjust.offtake = function(in.param,
                          low.threshold,
                          high.threshold,
                          p0 = 150) {
  #-- calculate phi.opt
  phi.opt = optimize(f = get.off.adjust.poff,
                     param.ref = in.param,
                     interval = c(0, 5))$minimum
  
  #-- get unadjusted female offtake
  f.off = in.param$poff[in.param$sex == "F" & in.param$class > 0]
  
  #-- extract tcla
  tcla1 = in.param[, c(1:5)]
  
  #-- extract lclass
  # lclass1 = in.param$lclass[ in.param$sex=="F" & in.param$class > 0 ]
  
  #-- get lambda
  lambda = HerdDynamics::get_lambda(param = in.param, tcla = tcla1, p0 = p0)$lambda
  
  #-- compare lambda to threshold value
  if (lambda < low.threshold | lambda >= high.threshold) {
    #-- if lambda below threshold, adjust female offtake
    in.param$poff[in.param$sex == "F" &
                    in.param$class > 0] = f.off * phi.opt
  } else {
    in.param$poff[in.param$sex == "F" & in.param$class > 0] = f.off
  }
  return(in.param)
}

``` 

## Reproject herd with optimal offtake adjustments
Now we obtain the upper and lower thresholds of growth rate (the 25% and 75% quantiles of $\lambda_{boot}$) from `lambda.list`.

```{r, set-lambda-threshold, echo=FALSE}
#-- set threshold as mean of all lambda
all.lambda = unlist(lambda.list[-c(which(str_detect(names(lambda.list), "Baseline")))])
Lambda.threshold = quantile(all.lambda)
Lambda.threshold.low = Lambda.threshold[[2]]
Lambda.threshold.high = Lambda.threshold[[4]]


```

We now run the `adjust.offtake` optimization algorithm for the 200 timesteps and project herds using the adjusted culling rates. This produces  a new `param` tables for every cycle. Based on $\lambda_{boot}$ estimates, the optimization function will adjust offtake if $\lambda$ is below `r Lambda.threshold.low` or above `r Lambda.threshold.high`. The resulting culling rates are passed to `projectHerd2()`. We then gather the results as before and merge them with the new results so they can be compared.

```{r, reproject-optimization, cache=TRUE, echo=TRUE}
#-- reproject with optimization
new.results = lapply(listpar, function(l) {
  l = lapply(
    l,
    FUN = adjust.offtake,
    low.threshold = Lambda.threshold.low,
    high.threshold = Lambda.threshold.high
  )
  projectHerd2(listpar = l, p0 = p0)
})

#-- send results to df
new.tot.pop.res = lapply(new.results, function(r) {
  pop_summary2(r, sex = FALSE, interval = "year")
})

# res2df(new.tot.pop.res) # this function is in the HerdDynamics package
new.pop.res.df = res.to.df(new.tot.pop.res)

#-- create column for offtake adjustment
tot.pop.df$offtake = "unadjusted"
new.pop.res.df$offtake = "adjusted"

#-- merge into a single data.frame
all.res.df = rbind.data.frame(tot.pop.df, new.pop.res.df)

```


```{r, plot-optimized-results, warning=FALSE, echo=FALSE, fig.dim=c(6,4), fig.cap="Figure S3.8. Projected sheep and goat populations after applying optimized offtake procedure for the Milk A and Benkovac-Barice strategies."}
plot.projection = function(df, offtake.list) {
  df %>%
    mutate(strategy = factor(strategy, levels = c(names(offtake.list))),
           Taxon = factor(Taxon, levels = c("goat", "sheep"))) %>%
    ggplot() +
    geom_col(aes(time, pop, fill = Taxon)) +
    scale_fill_manual(
      breaks = c("goat", "sheep"),
      values = cbPalette[c(1, 2)],
      labels = c("Goat", "Sheep")
    ) +
    labs(x = "Time (years)", y = "Number of animals") +
    facet_wrap(~ strategy,
               scales = "free_y" ,
               labeller = as_labeller(strip_labels)) +
    theme_minimal()
}

#-- plot for Energy and the Benkovac-Barice strategy
plot.projection(new.pop.res.df %>%
                  filter(str_detect(strategy, "Benkovac-Barice|MilkA")), offtake.list = offtake.mortality) +
  theme(legend.position = "bottom")
# plot.projection(tot.pop.df, offtake.list = offtake.mortality)
```


```{r plot-reprojection, message=FALSE, include=FALSE, eval=TRUE, fig.dim=c(6,4), fig.cap="Figure S3.9. Plots showing results of projections after applying optimized offtake adjustments to the various survivorship profiles used." }

#-- plot
Fig8 = all.res.df %>%
  group_by(time, strategy, offtake) %>%
  reframe(time, strategy, offtake, Taxon, pop, tot.pop = sum(pop)) %>% unique() %>%
  mutate(strategy = factor(strategy, levels = names(offtake.mortality)),
         Taxon = factor(Taxon, levels = c("goat", "sheep"))) %>%
  ggplot(aes(group = Taxon)) +
  geom_col(
    data = . %>% filter(offtake == "adjusted"),
    aes(time, pop, fill = Taxon),
    alpha = 0.8,
  ) +
  theme_minimal() +
  ylab("Number of Animals") +
  xlab("Time (years)") +
  scale_fill_manual(
    breaks = c("goat", "sheep"),
    values = cbPalette[c(1, 2)],
    labels = c("Goat", "Sheep")
  ) +
  theme(
    legend.position = "bottom",
    line = element_line(linewidth = 0.2),
    strip.text = element_text(size = 6),
    axis.text = element_text(size = 6),
    legend.text = element_text(size = 8),
    legend.title = element_text(size = 8),
    axis.title.x = element_text(size = 6),
    axis.title.y.left = element_text(size = 6),
  ) +
  facet_wrap(~ strategy ,
             scales = "free_y",
             labeller = as_labeller(strip_labels))

Fig8
ggsave(
  "Figures/Fig7_reprojections.jpg",
  plot =  Fig8,
  dpi = 300,
  width = 6,
  height = 4
)


```

# Part V - Evaluating optimization results
## Mean herd size
Using a modified version of `mmage::fprod()` we can view the mean herd size for projections with optimized culling rates.
```{r, xmean, echo=FALSE, fig.dim=c(6,4), fig.cap="Figure S3.10. Mean herd size after optimized culling rates applied"}
source("./R/mmagefprod.R")
new.vprod = do.call(rbind.data.frame, lapply(new.results, function(l) {
  fprod(formula = ~ 1, l$vecprod)
}))
new.vprod$Taxon = str_split_i(rownames(new.vprod), "\\.", i = 1)
new.vprod$strategy = str_split_i(rownames(new.vprod), "\\.", i = 2)
new.vprod = new.vprod %>%
  mutate(
    strategy = factor(strategy, levels = rev(names(offtake.mortality)), labels = rev(
      c(
        names(offtake.mortality)[1:5],
        "Meat A",
        "Meat B",
        "Milk A",
        "Milk B",
        names(offtake.mortality)[10:16]
      )
    )),
    Taxon = factor(Taxon, levels = c("goat", "sheep"))
  )

Fig9 =  new.vprod %>%
  # new.vprod %>%
  filter(strategy != "Baseline") %>%
  ggplot(aes(x = strategy, y = xmean, fill = Taxon)) +
  geom_col(position = position_dodge(width = c(0.7))) +
  geom_hline(yintercept = 150, linetype = "dashed") +
  ylab("Mean herd size over 200 years with optimized offtake") +
  xlab("Strategy") +
  theme_minimal() +
  annotate(geom = "text",
           x = 8,
           y = 135,
           label = "Initial \n Herd Size") +
  scale_fill_manual(
    breaks = c("goat", "sheep"),
    values = cbPalette,
    labels = c("Goat", "Sheep")
  ) +
  coord_flip() +
  theme(legend.position = "bottom")

Fig9
ggsave(
  "Figures/Fig8_mean_herd_size.jpg",
  plot =  Fig9,
  dpi = 300,
  width = 6,
  height = 4
)

```

## Multiplication rates

This chunk uses a modified version of `mmage::fm()` to obtain the annual multiplication rates of the optimized offtake (adjusted) and unadjusted simulations. 

```{r, compare-lambda, echo=TRUE}
#-- modified mmage function to get multiplication rate of the herd
source("R/mmagefm.R")

#-- summarize multiplication rate for old and new results
m.df = lapply(results, function(r) {
  o = mmage.fm(formula = ~ cycle , vecprod = r$vecprod)
  return(data.frame(cycle = o$cycle, m = o$m))
})
m.df = res.to.df(m.df)

new.m.df = lapply(new.results, function(r) {
  o = mmage.fm(formula = ~ cycle , vecprod = r$vecprod)
  return(data.frame(cycle = o$cycle, m = o$m))
})
new.m.df = res.to.df(new.m.df)

#-- create column for offtake adjustment
m.df$offtake = "unadjusted"
new.m.df$offtake = "adjusted"

#-- merge into a single data.frame
all.m.df = rbind.data.frame(m.df, new.m.df)
```


10-year moving averages of the multiplication rates were calculated to simplify illustration. This chunk defines functions to calculate the moving averages and detect detect maximum and minimum multiplication rates. These functions are used to produce Figures 9 and 10 in the associated article. 
```{r, summary-funs, echo=TRUE}
#-- Function to calculate moving average
calculate_moving_average <- function(time_series,
                                     window_size,
                                     type = c("simple", "exponential"),
                                     alpha = 0.1) {
  type <- match.arg(type)
  
  if (type == "simple") {
    # Calculate simple moving average
    moving_average <- zoo::rollmean(time_series,
                                    k = window_size,
                                    fill = NA,
                                    align = "right")
  } else if (type == "exponential") {
    # Calculate exponential moving average
    moving_average <- zoo::rollapply(
      time_series,
      width = window_size,
      FUN = function(x) {
        n <- length(x)
        weights <- (1 - alpha)^(n:1)
        sum(weights * x) / sum(weights)
      },
      fill = NA,
      align = "right"
    )
  }
  
  return(moving_average)
}

#-- Function to detect peaks
detect_peaks <- function(x, span = 3) {
  z <- embed(x, span)
  s <- span %/% 2
  v <- max.col(z, ties.method = "first") == 1 + s
  c(rep(FALSE, s), v, rep(FALSE, s))
}

#-- Function to detect valleys
detect_valleys <- function(x, span = 3) {
  z <- embed(x, span)
  s <- span %/% 2
  v <- apply(z, 1, which.min) == 1 + s
  c(rep(FALSE, s), v, rep(FALSE, s))
}

```


```{r, plot-functions, include=FALSE}
#-- labelers for sheep and goat plots
sheep.labeller = lambda.boot.df %>%
  mutate(
    taxon = str_split_i(rownames(lambda.boot.df), "\\.", 1),
    strategy = str_split_i(rownames(lambda.boot.df), "\\.", 2),
    lambda = round(t0, 3)
  ) %>%
  mutate(
    strat.lab = case_when(
      strategy == "MeatA" ~ "Meat A",
      strategy == "MeatB" ~ "Meat B",
      strategy == "MilkA" ~ "Milk A",
      strategy == "MilkB" ~ "Milk B",
      .default = strategy
    )
  ) %>%
  filter(taxon == "sheep") %>%
  select(strategy, strat.lab, lambda) %>%
  mutate(lambda.lab = paste0(strat.lab, "\n (", format(lambda, nsmall =
                                                         3), ")")) %>%
  select(strategy, lambda.lab)

sheep_labels = setNames(c(sheep.labeller$lambda.lab), c(sheep.labeller$strategy))

goat.labeller = lambda.boot.df %>%
  mutate(
    taxon = str_split_i(rownames(lambda.boot.df), "\\.", 1),
    strategy = str_split_i(rownames(lambda.boot.df), "\\.", 2),
    lambda = round(t0, 3)
  ) %>%
  mutate(
    strat.lab = case_when(
      strategy == "MeatA" ~ "Meat A",
      strategy == "MeatB" ~ "Meat B",
      strategy == "MilkA" ~ "Milk A",
      strategy == "MilkB" ~ "Milk B",
      .default = strategy
    )
  ) %>%
  filter(taxon == "goat") %>%
  select(strategy, strat.lab, lambda) %>%
  mutate(lambda.lab = paste0(strat.lab, "\n (", format(lambda, nsmall =
                                                         3), ")")) %>%
  select(strategy, lambda.lab)

#-- create label lists
goat_labels = setNames(c(goat.labeller$lambda.lab), c(goat.labeller$strategy))

plot.m = function(taxon = c("goat", "sheep")) {
  tax = match.arg(taxon)
  all.m.df %>%
    filter(Taxon == tax) %>%
    mutate(strategy = factor(strategy, levels = names(offtake.mortality))) %>%
    group_by(Taxon, strategy, offtake) %>%
    reframe(
      cycle,
      Taxon,
      strategy,
      offtake,
      m,
      m10 = calculate_moving_average(m, 10, type = "simple"),
      peak = detect_peaks(m10, span = 31),
      valley = detect_valleys(m10, span = 31)
    ) %>%
    filter(!is.na(m10)) %>%
    ggplot(aes(
      x = cycle,
      y = m10,
      group = offtake,
      colour = offtake
    )) +
    geom_line(lwd = 0.2) +
    geom_hline(
      yintercept = Lambda.threshold.low,
      linetype = "solid",
      lwd = 0.2,
      alpha = 0.8
    ) +
    geom_hline(
      yintercept = Lambda.threshold.high,
      linetype = "dashed",
      lwd = 0.2,
      alpha = 0.8
    ) +
    geom_point(
      data = . %>% filter(peak),
      aes(x = cycle, y = m10),
      shape = 24,
      fill = carto_pal(name = "Safe")[12],
      alpha = 0.8,
      size = 0.8,
      show.legend = F
    ) +
    geom_point(
      data = . %>% filter(valley),
      aes(x = cycle, y = m10),
      shape = 25,
      fill = carto_pal(name = "Safe")[12],
      alpha = 0.8,
      size = 0.8,
      show.legend = F
    ) +
    scale_color_manual(values = cbPalette[c(4, 6)], labels = c("m", "λ")) +
    ylab(paste0(expression("λ and m, ("), tax, ")")) + # "Lambda (sheep)") +
    xlab("Time (years)") +
    xlim(c(10, 200)) +
    scale_y_continuous(expand = c(0.02, 0.02)) +
    theme_minimal() +
    theme(
      legend.position = "bottom",
      strip.text = element_text(size = 8),
      axis.text.y = element_text(size = 6),
      axis.text.x = element_text(size = 6),
      legend.title = element_text(size = 10),
      axis.title = element_text(size = 10),
      line = element_line(linewidth = 0.2)
    ) +
    if (tax == "goat") {
      facet_wrap(~ strategy ,
                 scales = "free_y",
                 labeller = as_labeller(goat_labels)) # goat_labeller )
    } else {
      facet_wrap(~ strategy ,
                 scales = "free_y",
                 labeller = as_labeller(sheep_labels)) #  sheep_labeller )
    }
}

```

```{r, Fig11, warning=FALSE, echo=FALSE, eval=TRUE,  fig.dim=c(6,4), fig.cap="Figure S3.11. Showing multiplication rates of unadjusted and adjusted offtake rates for goats"}
plot.m("goat")
```

```{r, Fig12, warning=FALSE, echo=FALSE, eval=TRUE,  fig.dim=c(6,4), fig.cap="Figure S3.12. Showing multiplication rates of unadjusted and adjusted offtake rates for sheep"}
plot.m("sheep")
```

```{r, save-figs, include=FALSE, eval=FALSE}
# Fig8
ggsave(
  "Figures/Fig9_Lambda_goat.jpg",
  plot =  plot.m("goat") ,
  dpi = 300,
  width = 6,
  height = 4
)
# Fig9
ggsave(
  "Figures/Fig10_Lambda_sheep.jpg",
  plot =  plot.m("sheep") ,
  dpi = 300,
  width = 6,
  height = 4
)
```

### Levene's Test for Equality of Variance
A Levene's Test for Equality of variances is used to assess whether there was a change in interannual variance of herd growth rates before and after culling rates were optimized.
```{r, Levenes-Test, include = FALSE, warning=FALSE}

all.m.list = all.m.df %>%
  mutate(strategy = factor(
    strategy,
    levels = names(offtake.mortality),
    labels = c(
      names(offtake.mortality)[1:5],
      "Meat A",
      "Meat B",
      "Milk A",
      "Milk B",
      names(offtake.mortality)[10:16]
    )
  )) %>%
  group_by(strategy, Taxon) %>%
  group_split()

m.lev.res = lapply(all.m.list, function(l) {
  lev.res = l %>% with(car::leveneTest(m, offtake))
  data.frame(
    strategy = first(l$strategy),
    Taxon = first(l$Taxon),
    F.value = lev.res$`F value`[1],
    p = lev.res$`Pr(>F)`[1]
  )
})

lev.res.df = do.call(rbind.data.frame, m.lev.res)
#-- add lambda values from bootstrap results
lev.res.df$lambda[lev.res.df$Taxon == "goat"] = lambda.boot.df$t0[1:16]
lev.res.df$lambda[lev.res.df$Taxon == "sheep"] = lambda.boot.df$t0[17:32]

head(lev.res.df)
```

```{r, Levenes-TableC5, include=FALSE, eval=TRUE}


T5ft = lev.res.df %>%
  pivot_longer(cols = c("F.value", "p", "lambda")) %>%
  pivot_wider(names_from = c(Taxon, name)) %>%
  flextable() %>%
  bold(~ goat_p  < 0.05, ~ goat_p, bold = TRUE) %>%
  bold(~ sheep_p  < 0.05, ~ sheep_p, bold = TRUE) %>%
  separate_header(split = "_") %>%
  labelizor(
    part = "header",
    labels = c(
      "F.value" = "F",
      "p" = "p-value",
      "lambda" = "lambda"
    )
  ) %>%
  colformat_double(j = c(2:7), digits = 3) %>%
  set_table_properties(layout = "autofit", align = "center") %>%
  paginate(
    group = "strategy",
    # keep Sample.ID group across pages
    group_def = "rle"
  ) %>%
  autofit() %>%
  theme_vanilla()

T5ft %>% set_caption("Table C.5. Results of Levene's Test for equality of Variance")

#-- properties for word doc output
sect_properties <- prop_section(
  page_size = page_size(
    orient = "portrait",
    width = 8.5,
    height = 11
  ),
  type = "continuous",
  page_margins = page_mar(left = 1.25)
)
T5ft
#-- create output word doc
save_as_docx(T5ft, path = "./tables/Table6_Variance.docx", pr_section = sect_properties)

```



# References